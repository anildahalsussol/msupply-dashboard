{"version":3,"sources":["webpack:///./public/app/plugins/datasource/loki/syntax.ts","webpack:///./public/app/plugins/datasource/loki/language_provider.ts","webpack:///./public/app/plugins/datasource/loki/result_transformer.ts","webpack:///./public/app/plugins/datasource/loki/query_utils.ts","webpack:///./node_modules/rxjs/_esm5/internal/observable/dom/WebSocketSubject.js","webpack:///./public/app/plugins/datasource/loki/live_streams.ts","webpack:///./node_modules/rxjs/_esm5/internal/observable/dom/webSocket.js","webpack:///./public/app/plugins/datasource/loki/datasource.ts","webpack:///./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx","webpack:///./public/app/plugins/datasource/loki/components/LokiQueryField.tsx","webpack:///./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx","webpack:///./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx","webpack:///./public/app/plugins/datasource/loki/module.ts","webpack:///./public/app/plugins/datasource/prometheus/language_utils.ts","webpack:///./public/app/plugins/datasource/prometheus/add_label_to_query.ts"],"names":["syntax","comment","pattern","lookbehind","context-labels","inside","label-key","alias","label-value","greedy","punctuation","operator","RegExp","DEFAULT_KEYS","HISTORY_COUNT_CUTOFF","wrapLabel","label","rangeToParams","range","start","from","end","to","_super","LokiLanguageProvider","datasource","initialValues","_this","call","this","cleanText","s","replace","trim","request","url","params","metadataRequest","startTask","fetchLogLabels","initialRange","then","started","labelKeys","labelValues","Object","assign","tslib_es6","prototype","getSyntax","getLabelKeys","getLabelValues","key","Promise","fetchLabelValues","_a","sent","provideCompletionItems","input","context","wrapperClasses","value","empty","document","text","length","lodash_default","a","includes","getLabelCompletionItems","getEmptyCompletionItems","suggestions","history","historyItems","chain","map","h","query","expr","filter","uniq","take","item","cutoffTs","Date","now","historyForItem","ts","count","recent","hint","src","fromNow","documentation","addHistoryMetadata","push","prefixMatch","skipSort","items","_b","labelKey","absoluteRange","line","anchorBlock","getText","cursorOffset","selection","anchor","offset","selector","parsedSelector","language_utils","_d","existingKeys","match","_c","possibleKeys","difference","importQueries","queries","datasourceType","all","importPrometheusQuery","rest","refId","selectorMatch","labels_1","_","labelsToKeep_1","keys","sort","join","logLabelFetchTs","res","data","json","body","slice","logLabelOptions","isLeaf","console","error","e_1","refreshLogLabels","forceRefresh","values_1","keyOption","children","exisingValues","nextValues","e_2","explore","logStreamToDataFrame","stream","reverse","labels","parsedLabels","times","lines","uids","entries","next","done","entry","timestamp","add","buffer","fields","name","type","time","config","title","values","string","selectorRegexp","caseInsensitive","parseQuery","regexp","search","startsWith","formatQuery","getHighlighterExpressionsFromQuery","parsed","expression","results","filterStart","skip","substr","filterEnd","filterTerm","quotedTerm","unwrappedFilterTerm","DEFAULT_WEBSOCKET_CONFIG","deserializer","e","JSON","parse","serializer","stringify","WebSocketSubject_WebSocketSubject","WebSocketSubject","urlConfigOrSource","destination","Observable","source","_config","_output","Subject","hasOwnProperty","WebSocketCtor","WebSocket","Error","ReplaySubject","lift","sock","_resetState","_socket","multiplex","subMsg","unsubMsg","messageFilter","self","observer","err","subscription","subscribe","x","complete","unsubscribe","_connectSocket","protocol","binaryType","socket","Subscription","readyState","close","onopen","openObserver","queue","Subscriber","create","send","closingObserver","undefined","code","reason","TypeError","onerror","onclose","closeObserver","wasClean","onmessage","_subscribe","subscriber","observers","live_streams_LiveStreams","LiveStreams","streams","getStream","target","data_1","capacity","size","addField","other","pipe","finalize","response","streams_1","streams_1_1","unique","e_3","id","appendResponseToBufferedData","DEFAULT_MAX_LINES","DEFAULT_QUERY_PARAMS","direction","limit","serializeParams","k","v","encodeURIComponent","LokiDatasource","instanceSettings","backendSrv","templateSrv","processError","message","utils_explore","status","statusText","series","dataFrame","meta","searchWords","maxLines","runLiveQuery","options","liveTarget","prepareLiveTarget","state","Streaming","runQuery","prepareQueryTarget","_request","catch","cancelled","processResult","prepareLogRowContextQueryTarget","row","timeEpochNs","timeEpochMs","commontTargetOptons","trys","result","languageProvider","language_provider","settingsData","jsonData","$inject","apiUrl","req","datasourceRequest","baseUrl","Math","min","maxDataPoints","Infinity","getTime","targets","hide","liveStreaming","merge","apply","subQueries","interpolateVariablesInQueries","expandedQueries","silent","modifyQuery","action","add_label_to_query","getHighlighterExpression","date","roundUp","isString","ceil","valueOf","testDatasource","annotation","requestId","dashboardId","dashboard","scopedVars","startTime","timezone","panelId","interval","intervalMs","queryRequestFromAnnotationOptions","frame","tags","forEachRow","data_1_1","_loop_1","DEFAULT_EXAMPLES","PREFERRED_LABELS","EXAMPLES_LIMIT","LokiCheatSheet","arguments","userExamples","props","provider","find","l","lodash","preferredLabel_1","componentDidMount","scheduleUserLabelChecking","componentWillUnmount","clearTimeout","userLabelTimer","setTimeout","checkUserLabels","renderExpression","onClickExample","react_default","createElement","className","onClick","render","Fragment","example","href","LokiQueryField","datasourceStatus","otherProps","useLokiSyntax","isSyntaxReady","setActiveOption","refreshLabels","syntaxProps","LokiQueryFieldForm","syntaxLoaded","onLoadOptions","onLabelsRefresh","react","absolute","onChange","onRunQuery","grafana_ui_src","Connected","LokiAnnotationsQueryCtrl","onQueryChange","bind","templateUrl","__webpack_require__","d","__webpack_exports__","LokiConfigCtrl","loki_datasource","components_LokiQueryEditor","components_LokiQueryField","components_LokiCheatSheet","processHistogramLabels","index","test","indexOf","__name__","processLabels","withName","forEach","tslib__WEBPACK_IMPORTED_MODULE_0__","labelRegexp","parseSelector","prefix","prefixOpen","lastIndexOf","prefixClose","suffix","suffixClose","suffixOpenIndex","suffixOpen","metricMatch","cleanSelector","expandRecordingRules","mapping","ruleNames","rulesRegex","pre","post","addLabelToSelector","lodash__WEBPACK_IMPORTED_MODULE_0__","lodash__WEBPACK_IMPORTED_MODULE_0___default","n","keywords","builtInWords","split","metricNameRegexp","labelValue","labelOperator","exec","operatorForLabelKey","uniqWith","isEqual","compact","sortBy","previousWord","word","position","openChar","closeChar","nextSelectorStart","nextSelectorEnd","insideSelector","previousWordIsKeyWord","isColonBounded","endsWith","parts","lastIndex","selectorWithLabel"],"mappings":"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","file":"lokiPlugin.18f32a9f431162a774b4.js","sourcesContent":["import { Grammar } from 'prismjs';\n\n/* tslint:disable max-line-length */\n\nconst tokenizer: Grammar = {\n  comment: {\n    pattern: /(^|[^\\n])#.*/,\n    lookbehind: true,\n  },\n  'context-labels': {\n    pattern: /(^|\\s)\\{[^}]*(?=})/,\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n      punctuation: /[{]/,\n    },\n  },\n  // number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: new RegExp(`/&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?`, 'i'),\n  punctuation: /[{}`,.]/,\n};\n\nexport default tokenizer;\n","// Libraries\nimport _ from 'lodash';\n\n// Services & Utils\nimport { parseSelector, labelRegexp, selectorRegexp } from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax from './syntax';\n\n// Types\nimport { CompletionItem, LanguageProvider, TypeaheadInput, TypeaheadOutput, HistoryItem } from 'app/types/explore';\nimport { LokiQuery } from './types';\nimport { dateTime, AbsoluteTimeRange } from '@grafana/data';\nimport { PromQuery } from '../prometheus/types';\n\nimport LokiDatasource from './datasource';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label });\nexport const rangeToParams = (range: AbsoluteTimeRange) => ({ start: range.from * NS_IN_MS, end: range.to * NS_IN_MS });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && (h.query.expr as string) === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys?: { [index: string]: string[] }; // metric -> [labelKey,...]\n  labelValues?: { [index: string]: { [index: string]: string[] } }; // metric -> labelKey -> [labelValue,...]\n  logLabelOptions: any[];\n  logLabelFetchTs?: number;\n  started: boolean;\n  initialRange: AbsoluteTimeRange;\n  datasource: LokiDatasource;\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = {};\n    this.labelValues = {};\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%]/g, '').trim();\n\n  getSyntax() {\n    return syntax;\n  }\n\n  request = (url: string, params?: any) => {\n    return this.datasource.metadataRequest(url, params);\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLogLabels(this.initialRange).then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys[EMPTY_SELECTOR];\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    await this.fetchLabelValues(key, this.initialRange);\n    return this.labelValues[EMPTY_SELECTOR][key];\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value } = input;\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    // Determine candidates by CSS context\n    if (_.includes(wrapperClasses, 'context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input, context);\n    } else if (empty) {\n      return this.getEmptyCompletionItems(context || {});\n    }\n\n    return {\n      suggestions: [],\n    };\n  }\n\n  getEmptyCompletionItems(context: any): TypeaheadOutput {\n    const { history } = context;\n    const suggestions = [];\n\n    if (history && history.length > 0) {\n      const historyItems = _.chain(history)\n        .map((h: any) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item: CompletionItem) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  async getLabelCompletionItems(\n    { text, wrapperClasses, labelKey, value }: TypeaheadInput,\n    { absoluteRange }: any\n  ): Promise<TypeaheadOutput> {\n    let context: string;\n    const suggestions = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset: number = value.selection.anchor.offset;\n\n    // Use EMPTY_SELECTOR until series API is implemented for facetting\n    const selector = EMPTY_SELECTOR;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n    } catch {}\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    if ((text && text.match(/^!?=~?/)) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && this.labelValues[selector]) {\n        let labelValues = this.labelValues[selector][labelKey];\n        if (!labelValues) {\n          await this.fetchLabelValues(labelKey, absoluteRange);\n          labelValues = this.labelValues[selector][labelKey];\n        }\n\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          items: labelValues.map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = this.labelKeys[selector] || DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length > 0) {\n          context = 'context-labels';\n          suggestions.push({ label: `Labels`, items: possibleKeys.map(wrapLabel) });\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  async importQueries(queries: LokiQuery[], datasourceType: string): Promise<LokiQuery[]> {\n    if (datasourceType === 'prometheus') {\n      return Promise.all(\n        queries.map(async query => {\n          const expr = await this.importPrometheusQuery(query.expr);\n          const { context, ...rest } = query as PromQuery;\n          return {\n            ...rest,\n            expr,\n          };\n        })\n      );\n    }\n    // Return a cleaned LokiQuery\n    return queries.map(query => ({\n      refId: query.refId,\n      expr: '',\n    }));\n  }\n\n  async importPrometheusQuery(query: string): Promise<string> {\n    if (!query) {\n      return '';\n    }\n\n    // Consider only first selector in query\n    const selectorMatch = query.match(selectorRegexp);\n    if (selectorMatch) {\n      const selector = selectorMatch[0];\n      const labels: { [key: string]: { value: any; operator: any } } = {};\n      selector.replace(labelRegexp, (_, key, operator, value) => {\n        labels[key] = { value, operator };\n        return '';\n      });\n\n      // Keep only labels that exist on origin and target datasource\n      await this.start(); // fetches all existing label keys\n      const existingKeys = this.labelKeys[EMPTY_SELECTOR];\n      let labelsToKeep: { [key: string]: { value: any; operator: any } } = {};\n      if (existingKeys && existingKeys.length > 0) {\n        // Check for common labels\n        for (const key in labels) {\n          if (existingKeys && existingKeys.includes(key)) {\n            // Should we check for label value equality here?\n            labelsToKeep[key] = labels[key];\n          }\n        }\n      } else {\n        // Keep all labels by default\n        labelsToKeep = labels;\n      }\n\n      const labelKeys = Object.keys(labelsToKeep).sort();\n      const cleanSelector = labelKeys\n        .map(key => `${key}${labelsToKeep[key].operator}${labelsToKeep[key].value}`)\n        .join(',');\n\n      return ['{', cleanSelector, '}'].join('');\n    }\n\n    return '';\n  }\n\n  async fetchLogLabels(absoluteRange: AbsoluteTimeRange): Promise<any> {\n    const url = '/api/prom/label';\n    try {\n      this.logLabelFetchTs = Date.now();\n\n      const res = await this.request(url, rangeToParams(absoluteRange));\n      const body = await (res.data || res.json());\n      const labelKeys = body.data.slice().sort();\n      this.labelKeys = {\n        ...this.labelKeys,\n        [EMPTY_SELECTOR]: labelKeys,\n      };\n      this.labelValues = {\n        [EMPTY_SELECTOR]: {},\n      };\n      this.logLabelOptions = labelKeys.map((key: string) => ({ label: key, value: key, isLeaf: false }));\n    } catch (e) {\n      console.error(e);\n    }\n    return [];\n  }\n\n  async refreshLogLabels(absoluteRange: AbsoluteTimeRange, forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now() - this.logLabelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLogLabels(absoluteRange);\n    }\n  }\n\n  async fetchLabelValues(key: string, absoluteRange: AbsoluteTimeRange) {\n    const url = `/api/prom/label/${key}/values`;\n    try {\n      const res = await this.request(url, rangeToParams(absoluteRange));\n      const body = await (res.data || res.json());\n      const values = body.data.slice().sort();\n\n      // Add to label options\n      this.logLabelOptions = this.logLabelOptions.map(keyOption => {\n        if (keyOption.value === key) {\n          return {\n            ...keyOption,\n            children: values.map((value: string) => ({ label: value, value })),\n          };\n        }\n        return keyOption;\n      });\n\n      // Add to key map\n      const exisingValues = this.labelValues[EMPTY_SELECTOR];\n      const nextValues = {\n        ...exisingValues,\n        [key]: values,\n      };\n      this.labelValues = {\n        ...this.labelValues,\n        [EMPTY_SELECTOR]: nextValues,\n      };\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n","import { LokiLogsStream, LokiResponse } from './types';\nimport {\n  parseLabels,\n  FieldType,\n  Labels,\n  DataFrame,\n  ArrayVector,\n  MutableDataFrame,\n  findUniqueLabels,\n} from '@grafana/data';\n\n/**\n * Transforms LokiLogStream structure into a dataFrame. Used when doing standard queries.\n */\nexport function logStreamToDataFrame(stream: LokiLogsStream, reverse?: boolean, refId?: string): DataFrame {\n  let labels: Labels = stream.parsedLabels;\n  if (!labels && stream.labels) {\n    labels = parseLabels(stream.labels);\n  }\n  const times = new ArrayVector<string>([]);\n  const lines = new ArrayVector<string>([]);\n  const uids = new ArrayVector<string>([]);\n\n  for (const entry of stream.entries) {\n    const ts = entry.ts || entry.timestamp;\n    times.add(ts);\n    lines.add(entry.line);\n    uids.add(`${ts}_${stream.labels}`);\n  }\n\n  if (reverse) {\n    times.buffer = times.buffer.reverse();\n    lines.buffer = lines.buffer.reverse();\n  }\n\n  return {\n    refId,\n    labels,\n    fields: [\n      { name: 'ts', type: FieldType.time, config: { title: 'Time' }, values: times }, // Time\n      { name: 'line', type: FieldType.string, config: {}, values: lines }, // Line\n      { name: 'id', type: FieldType.string, config: {}, values: uids },\n    ],\n    length: times.length,\n  };\n}\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n * @param response\n * @param data Needs to have ts, line, labels, id as fields\n */\nexport function appendResponseToBufferedData(response: LokiResponse, data: MutableDataFrame) {\n  // Should we do anything with: response.dropped_entries?\n\n  const streams: LokiLogsStream[] = response.streams;\n  if (streams && streams.length) {\n    for (const stream of streams) {\n      // Find unique labels\n      const labels = parseLabels(stream.labels);\n      const unique = findUniqueLabels(labels, data.labels || {});\n\n      // Add each line\n      for (const entry of stream.entries) {\n        const ts = entry.ts || entry.timestamp;\n        data.values.ts.add(ts);\n        data.values.line.add(entry.line);\n        data.values.labels.add(unique);\n        data.values.id.add(`${ts}_${stream.labels}`);\n      }\n    }\n  }\n}\n","import { LokiExpression } from './types';\n\nconst selectorRegexp = /(?:^|\\s){[^{]*}/g;\nconst caseInsensitive = '(?i)'; // Golang mode modifier for Loki, doesn't work in JavaScript\nexport function parseQuery(input: string): LokiExpression {\n  input = input || '';\n  const match = input.match(selectorRegexp);\n  let query = input;\n  let regexp = '';\n\n  if (match) {\n    regexp = input.replace(selectorRegexp, '').trim();\n    // Keep old-style regexp, otherwise take whole query\n    if (regexp && regexp.search(/\\|=|\\|~|!=|!~/) === -1) {\n      query = match[0].trim();\n      if (!regexp.startsWith(caseInsensitive)) {\n        regexp = `${caseInsensitive}${regexp}`;\n      }\n    } else {\n      regexp = '';\n    }\n  }\n\n  return { regexp, query };\n}\n\nexport function formatQuery(selector: string, search: string): string {\n  return `${selector || ''} ${search || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  const parsed = parseQuery(input);\n  // Legacy syntax\n  if (parsed.regexp) {\n    return [parsed.regexp];\n  }\n  let expression = input;\n  const results = [];\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const skip = expression.substr(filterStart).search(/!=|!~/) === 0;\n    expression = expression.substr(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.substr(0, filterEnd).trim();\n      expression = expression.substr(filterEnd);\n    }\n\n    // Unwrap the filter term by removing quotes\n    const quotedTerm = filterTerm.match(/^\"((?:[^\\\\\"]|\\\\\")*)\"$/);\n\n    if (quotedTerm) {\n      const unwrappedFilterTerm = quotedTerm[1];\n      results.push(unwrappedFilterTerm);\n    } else {\n      return null;\n    }\n  }\n  return results;\n}\n","/** PURE_IMPORTS_START tslib,_.._Subject,_.._Subscriber,_.._Observable,_.._Subscription,_.._ReplaySubject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = _this._config = tslib_1.__assign({}, DEFAULT_WEBSOCKET_CONFIG);\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe(function (x) {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ?\n                new WebSocketCtor(url, protocol) :\n                new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (e) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (e) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && _socket.readyState === 1) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && _socket.readyState === 1) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map\n","import { DataFrame, FieldType, parseLabels, KeyValue, CircularDataFrame } from '@grafana/data';\nimport { Observable } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nimport { LokiResponse } from './types';\nimport { finalize, map } from 'rxjs/operators';\nimport { appendResponseToBufferedData } from './result_transformer';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LiveTarget {\n  query: string;\n  regexp: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LiveTarget): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n    if (!stream) {\n      const data = new CircularDataFrame({ capacity: target.size });\n      data.labels = parseLabels(target.query);\n      data.addField({ name: 'ts', type: FieldType.time, config: { title: 'Time' } });\n      data.addField({ name: 'line', type: FieldType.string });\n      data.addField({ name: 'labels', type: FieldType.other });\n      data.addField({ name: 'id', type: FieldType.string });\n\n      stream = webSocket(target.url).pipe(\n        finalize(() => {\n          delete this.streams[target.url];\n        }),\n        map((response: LokiResponse) => {\n          appendResponseToBufferedData(response, data);\n          return [data];\n        })\n      );\n      this.streams[target.url] = stream;\n    }\n    return stream;\n  }\n}\n","/** PURE_IMPORTS_START _WebSocketSubject PURE_IMPORTS_END */\nimport { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map\n","// Libraries\nimport _ from 'lodash';\n// Services & Utils\nimport {\n  dateMath,\n  DataFrame,\n  LogRowModel,\n  DateTime,\n  AnnotationEvent,\n  DataFrameView,\n  LoadingState,\n} from '@grafana/data';\nimport { addLabelToSelector } from 'app/plugins/datasource/prometheus/add_label_to_query';\nimport LanguageProvider from './language_provider';\nimport { logStreamToDataFrame } from './result_transformer';\nimport { formatQuery, parseQuery, getHighlighterExpressionsFromQuery } from './query_utils';\n// Types\nimport {\n  PluginMeta,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  AnnotationQueryRequest,\n} from '@grafana/ui';\n\nimport { LokiQuery, LokiOptions, LokiLogsStream, LokiResponse } from './types';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { safeStringifyValue, convertToWebSocketUrl } from 'app/core/utils/explore';\nimport { LiveTarget, LiveStreams } from './live_streams';\nimport { Observable, from, merge } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\nexport const DEFAULT_MAX_LINES = 1000;\n\nconst DEFAULT_QUERY_PARAMS = {\n  direction: 'BACKWARD',\n  limit: DEFAULT_MAX_LINES,\n  regexp: '',\n  query: '',\n};\n\nfunction serializeParams(data: any) {\n  return Object.keys(data)\n    .map(k => {\n      const v = data[k];\n      return encodeURIComponent(k) + '=' + encodeURIComponent(v);\n    })\n    .join('&');\n}\n\ninterface LokiContextQueryOptions {\n  direction?: 'BACKWARD' | 'FORWARD';\n  limit?: number;\n}\n\nexport class LokiDatasource extends DataSourceApi<LokiQuery, LokiOptions> {\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  /** @ngInject */\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    super(instanceSettings);\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines, 10) || DEFAULT_MAX_LINES;\n  }\n\n  _request(apiUrl: string, data?: any, options?: any) {\n    const baseUrl = this.instanceSettings.url;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}?${params}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return this.backendSrv.datasourceRequest(req);\n  }\n\n  prepareLiveTarget(target: LokiQuery, options: DataQueryRequest<LokiQuery>): LiveTarget {\n    const interpolated = this.templateSrv.replace(target.expr);\n    const { query, regexp } = parseQuery(interpolated);\n    const refId = target.refId;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query, regexp });\n    const url = convertToWebSocketUrl(`${baseUrl}/api/prom/tail?${params}`);\n\n    return {\n      query,\n      regexp,\n      url,\n      refId,\n      size: Math.min(options.maxDataPoints || Infinity, this.maxLines),\n    };\n  }\n\n  prepareQueryTarget(target: LokiQuery, options: DataQueryRequest<LokiQuery>) {\n    const interpolated = this.templateSrv.replace(target.expr);\n    const { query, regexp } = parseQuery(interpolated);\n    const start = this.getTime(options.range.from, false);\n    const end = this.getTime(options.range.to, true);\n    const refId = target.refId;\n    return {\n      ...DEFAULT_QUERY_PARAMS,\n      query,\n      regexp,\n      start,\n      end,\n      limit: Math.min(options.maxDataPoints || Infinity, this.maxLines),\n      refId,\n    };\n  }\n\n  processError = (err: any, target: any): DataQueryError => {\n    const error: DataQueryError = {\n      message: 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  processResult = (data: LokiLogsStream | LokiResponse, target: any): DataFrame[] => {\n    const series: DataFrame[] = [];\n\n    if (Object.keys(data).length === 0) {\n      return series;\n    }\n\n    if (!(data as any).streams) {\n      return [logStreamToDataFrame(data as LokiLogsStream, false, target.refId)];\n    }\n\n    data = data as LokiResponse;\n    for (const stream of data.streams || []) {\n      const dataFrame = logStreamToDataFrame(stream);\n      dataFrame.refId = target.refId;\n      dataFrame.meta = {\n        searchWords: getHighlighterExpressionsFromQuery(formatQuery(target.query, target.regexp)),\n        limit: this.maxLines,\n      };\n      series.push(dataFrame);\n    }\n\n    return series;\n  };\n\n  /**\n   * Runs live queries which in this case means creating a websocket and listening on it for new logs.\n   * This returns a bit different dataFrame than runQueries as it returns single dataframe even if there are multiple\n   * Loki streams, sets only common labels on dataframe.labels and has additional dataframe.fields.labels for unique\n   * labels per row.\n   *\n   * @param options\n   * @param observer Callback that will be called with new data. Is optional but only because we run this function\n   * even if there are no live targets defined in the options which would mean this is noop and observer is not called.\n   */\n  runLiveQuery = (options: DataQueryRequest<LokiQuery>, target: LokiQuery): Observable<DataQueryResponse> => {\n    const liveTarget = this.prepareLiveTarget(target, options);\n    const stream = this.streams.getStream(liveTarget);\n    return stream.pipe(\n      map(data => {\n        return {\n          data,\n          key: `loki-${liveTarget.refId}`,\n          state: LoadingState.Streaming,\n        };\n      })\n    );\n  };\n\n  runQuery = (options: DataQueryRequest<LokiQuery>, target: LokiQuery): Observable<DataQueryResponse> => {\n    const query = this.prepareQueryTarget(target, options);\n    return from(\n      this._request('/api/prom/query', query).catch((err: any) => {\n        if (err.cancelled) {\n          return err;\n        }\n\n        const error: DataQueryError = this.processError(err, query);\n        throw error;\n      })\n    ).pipe(\n      filter((response: any) => (response.cancelled ? false : true)),\n      map((response: any) => {\n        const data = this.processResult(response.data, query);\n        return { data, key: query.refId };\n      })\n    );\n  };\n\n  query(options: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const subQueries = options.targets\n      .filter(target => target.expr && !target.hide)\n      .map(target => {\n        if (target.liveStreaming) {\n          return this.runLiveQuery(options, target);\n        }\n        return this.runQuery(options, target);\n      });\n\n    return merge(...subQueries);\n  }\n\n  interpolateVariablesInQueries(queries: LokiQuery[]): LokiQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          expr: this.templateSrv.replace(query.expr),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  async importQueries(queries: LokiQuery[], originMeta: PluginMeta): Promise<LokiQuery[]> {\n    return this.languageProvider.importQueries(queries, originMeta.id);\n  }\n\n  metadataRequest(url: string, params?: any) {\n    // HACK to get label values for {job=|}, will be replaced when implementing LokiQueryField\n    const apiUrl = url.replace('v1', 'prom');\n    return this._request(apiUrl, params, { silent: true }).then((res: DataQueryResponse) => {\n      const data: any = { data: { data: res.data.values || [] } };\n      return data;\n    });\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    const parsed = parseQuery(query.expr || '');\n    let { query: selector } = parsed;\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        selector = addLabelToSelector(selector, action.key, action.value);\n        break;\n      }\n      default:\n        break;\n    }\n    const expression = formatQuery(selector, parsed.regexp);\n    return { ...query, expr: expression };\n  }\n\n  getHighlighterExpression(query: LokiQuery): string[] {\n    return getHighlighterExpressionsFromQuery(query.expr);\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (_.isString(date)) {\n      date = dateMath.parse(date, roundUp);\n    }\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  prepareLogRowContextQueryTarget = (row: LogRowModel, limit: number, direction: 'BACKWARD' | 'FORWARD') => {\n    const query = Object.keys(row.labels)\n      .map(label => {\n        return `${label}=\"${row.labels[label]}\"`;\n      })\n      .join(',');\n    const contextTimeBuffer = 2 * 60 * 60 * 1000 * 1e6; // 2h buffer\n    const timeEpochNs = row.timeEpochMs * 1e6;\n\n    const commontTargetOptons = {\n      limit,\n      query: `{${query}}`,\n      direction,\n    };\n\n    if (direction === 'BACKWARD') {\n      return {\n        ...commontTargetOptons,\n        start: timeEpochNs - contextTimeBuffer,\n        end: row.timestamp, // using RFC3339Nano format to avoid precision loss\n        direction,\n      };\n    } else {\n      return {\n        ...commontTargetOptons,\n        start: row.timestamp, // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        end: timeEpochNs + contextTimeBuffer,\n      };\n    }\n  };\n\n  getLogRowContext = async (row: LogRowModel, options?: LokiContextQueryOptions) => {\n    const target = this.prepareLogRowContextQueryTarget(\n      row,\n      (options && options.limit) || 10,\n      (options && options.direction) || 'BACKWARD'\n    );\n    const series: DataFrame[] = [];\n\n    try {\n      const reverse = options && options.direction === 'FORWARD';\n      const result = await this._request('/api/prom/query', target);\n      if (result.data) {\n        for (const stream of result.data.streams || []) {\n          series.push(logStreamToDataFrame(stream, reverse));\n        }\n      }\n\n      return {\n        data: series,\n      };\n    } catch (e) {\n      const error: DataQueryError = {\n        message: 'Error during context query. Please check JS console logs.',\n        status: e.status,\n        statusText: e.statusText,\n      };\n      throw error;\n    }\n  };\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const startMs = Date.now() - 10 * 60 * 1000;\n    const start = `${startMs}000000`; // API expects nanoseconds\n    return this._request('/api/prom/label', { start })\n      .then((res: DataQueryResponse) => {\n        if (res && res.data && res.data.values && res.data.values.length > 0) {\n          return { status: 'success', message: 'Data source connected and labels found.' };\n        }\n        return {\n          status: 'error',\n          message:\n            'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n        };\n      })\n      .catch((err: any) => {\n        let message = 'Loki: ';\n        if (err.statusText) {\n          message += err.statusText;\n        } else {\n          message += 'Cannot connect to Loki';\n        }\n\n        if (err.status) {\n          message += `. ${err.status}`;\n        }\n\n        if (err.data && err.data.message) {\n          message += `. ${err.data.message}`;\n        } else if (err.data) {\n          message += `. ${err.data}`;\n        }\n        return { status: 'error', message: message };\n      });\n  }\n\n  async annotationQuery(options: AnnotationQueryRequest<LokiQuery>): Promise<AnnotationEvent[]> {\n    if (!options.annotation.expr) {\n      return [];\n    }\n\n    const request = queryRequestFromAnnotationOptions(options);\n    const { data } = await this.runQuery(request, request.targets[0]).toPromise();\n    const annotations: AnnotationEvent[] = [];\n\n    for (const frame of data) {\n      const tags = Object.values(frame.labels) as string[];\n      const view = new DataFrameView<{ ts: string; line: string }>(frame);\n\n      view.forEachRow(row => {\n        annotations.push({\n          time: new Date(row.ts).valueOf(),\n          text: row.line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n}\n\nfunction queryRequestFromAnnotationOptions(options: AnnotationQueryRequest<LokiQuery>): DataQueryRequest<LokiQuery> {\n  const refId = `annotation-${options.annotation.name}`;\n  const target: LokiQuery = { refId, expr: options.annotation.expr };\n\n  return {\n    requestId: refId,\n    range: options.range,\n    targets: [target],\n    dashboardId: options.dashboard.id,\n    scopedVars: null,\n    startTime: Date.now(),\n\n    // This should mean the default defined on datasource is used.\n    maxDataPoints: 0,\n\n    // Dummy values, are required in type but not used here.\n    timezone: 'utc',\n    panelId: 0,\n    interval: '',\n    intervalMs: 0,\n  };\n}\n\nexport default LokiDatasource;\n","import React, { PureComponent } from 'react';\nimport { shuffle } from 'lodash';\nimport { ExploreStartPageProps, DataQuery } from '@grafana/ui';\nimport LokiLanguageProvider from '../language_provider';\n\nconst DEFAULT_EXAMPLES = ['{job=\"default/prometheus\"}'];\nconst PREFERRED_LABELS = ['job', 'app', 'k8s_app'];\nconst EXAMPLES_LIMIT = 5;\n\nexport default class LokiCheatSheet extends PureComponent<ExploreStartPageProps, { userExamples: string[] }> {\n  userLabelTimer: NodeJS.Timeout;\n  state = {\n    userExamples: DEFAULT_EXAMPLES,\n  };\n\n  componentDidMount() {\n    this.scheduleUserLabelChecking();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.userLabelTimer);\n  }\n\n  scheduleUserLabelChecking() {\n    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);\n  }\n\n  checkUserLabels = async () => {\n    // Set example from user labels\n    const provider: LokiLanguageProvider = this.props.datasource.languageProvider;\n    if (provider.started) {\n      const labels = provider.getLabelKeys() || [];\n      const preferredLabel = PREFERRED_LABELS.find(l => labels.includes(l));\n      if (preferredLabel) {\n        const values = await provider.getLabelValues(preferredLabel);\n        const userExamples = shuffle(values)\n          .slice(0, EXAMPLES_LIMIT)\n          .map(value => `{${preferredLabel}=\"${value}\"}`);\n        this.setState({ userExamples });\n      }\n    } else {\n      this.scheduleUserLabelChecking();\n    }\n  };\n\n  renderExpression(expr: string) {\n    const { onClickExample } = this.props;\n\n    return (\n      <div\n        className=\"cheat-sheet-item__example\"\n        key={expr}\n        onClick={e => onClickExample({ refId: 'A', expr } as DataQuery)}\n      >\n        <code>{expr}</code>\n      </div>\n    );\n  }\n\n  render() {\n    const { userExamples } = this.state;\n\n    return (\n      <>\n        <h2>Loki Cheat Sheet</h2>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">See your logs</div>\n          <div className=\"cheat-sheet-item__label\">Start by selecting a log stream from the Log labels selector.</div>\n          <div className=\"cheat-sheet-item__label\">\n            Alternatively, you can write a stream selector into the query field:\n          </div>\n          {this.renderExpression('{job=\"default/prometheus\"}')}\n          {userExamples !== DEFAULT_EXAMPLES && userExamples.length > 0 ? (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here are some example streams from your logs:</div>\n              {userExamples.map(example => this.renderExpression(example))}\n            </div>\n          ) : null}\n        </div>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Combine stream selectors</div>\n          {this.renderExpression('{app=\"cassandra\",namespace=\"prod\"}')}\n          <div className=\"cheat-sheet-item__label\">Returns all log lines from streams that have both labels.</div>\n        </div>\n\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Filtering for search terms.</div>\n          {this.renderExpression('{app=\"cassandra\"} |~ \"(duration|latency)s*(=|is|of)s*[d.]+\"')}\n          {this.renderExpression('{app=\"cassandra\"} |= \"exact match\"')}\n          {this.renderExpression('{app=\"cassandra\"} != \"do not match\"')}\n          <div className=\"cheat-sheet-item__label\">\n            <a href=\"https://github.com/grafana/loki/blob/master/docs/logql.md#filter-expression\" target=\"logql\">\n              LogQL\n            </a>{' '}\n            supports exact and regular expression filters.\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n","import React, { FunctionComponent } from 'react';\nimport { LokiQueryFieldForm, LokiQueryFieldFormProps } from './LokiQueryFieldForm';\nimport { useLokiSyntax } from './useLokiSyntax';\nimport LokiLanguageProvider from '../language_provider';\n\nexport const LokiQueryField: FunctionComponent<LokiQueryFieldFormProps> = ({\n  datasource,\n  datasourceStatus,\n  ...otherProps\n}) => {\n  const { isSyntaxReady, setActiveOption, refreshLabels, ...syntaxProps } = useLokiSyntax(\n    datasource.languageProvider as LokiLanguageProvider,\n    datasourceStatus,\n    otherProps.absoluteRange\n  );\n\n  return (\n    <LokiQueryFieldForm\n      datasource={datasource}\n      datasourceStatus={datasourceStatus}\n      syntaxLoaded={isSyntaxReady}\n      /**\n       * setActiveOption name is intentional. Because of the way rc-cascader requests additional data\n       * https://github.com/react-component/cascader/blob/master/src/Cascader.jsx#L165\n       * we are notyfing useLokiSyntax hook, what the active option is, and then it's up to the hook logic\n       * to fetch data of options that aren't fetched yet\n       */\n      onLoadOptions={setActiveOption}\n      onLabelsRefresh={refreshLabels}\n      {...syntaxProps}\n      {...otherProps}\n    />\n  );\n};\n\nexport default LokiQueryField;\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { AbsoluteTimeRange } from '@grafana/data';\nimport { QueryEditorProps, DataSourceStatus } from '@grafana/ui';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\nimport { useLokiSyntax } from './useLokiSyntax';\n\ntype Props = QueryEditorProps<LokiDatasource, LokiQuery>;\n\nexport const LokiQueryEditor = memo(function LokiQueryEditor(props: Props) {\n  const { query, data, datasource, onChange, onRunQuery } = props;\n\n  let absolute: AbsoluteTimeRange;\n  if (data && data.request) {\n    const { range } = data.request;\n    absolute = {\n      from: range.from.valueOf(),\n      to: range.to.valueOf(),\n    };\n  } else {\n    absolute = {\n      from: Date.now() - 10000,\n      to: Date.now(),\n    };\n  }\n\n  const { isSyntaxReady, setActiveOption, refreshLabels, ...syntaxProps } = useLokiSyntax(\n    datasource.languageProvider,\n    // TODO maybe use real status\n    DataSourceStatus.Connected,\n    absolute\n  );\n\n  return (\n    <div>\n      <LokiQueryField\n        datasource={datasource}\n        datasourceStatus={DataSourceStatus.Connected}\n        query={query}\n        onChange={onChange}\n        onRunQuery={onRunQuery}\n        history={[]}\n        data={data}\n        onLoadOptions={setActiveOption}\n        onLabelsRefresh={refreshLabels}\n        syntaxLoaded={isSyntaxReady}\n        absoluteRange={absolute}\n        {...syntaxProps}\n      />\n    </div>\n  );\n});\n\nexport default LokiQueryEditor;\n","/**\n * Just a simple wrapper for a react component that is actually implementing the query editor.\n */\nexport class LokiAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  annotation: any;\n\n  /** @ngInject */\n  constructor() {\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(expr: string) {\n    this.annotation.expr = expr;\n  }\n}\n","import Datasource from './datasource';\n\nimport LokiCheatSheet from './components/LokiCheatSheet';\nimport LokiQueryField from './components/LokiQueryField';\nimport LokiQueryEditor from './components/LokiQueryEditor';\nimport { LokiAnnotationsQueryCtrl } from './LokiAnnotationsQueryCtrl';\n\nexport class LokiConfigCtrl {\n  static templateUrl = 'partials/config.html';\n}\n\nexport {\n  Datasource,\n  LokiQueryEditor as QueryEditor,\n  LokiConfigCtrl as ConfigCtrl,\n  LokiQueryField as ExploreQueryField,\n  LokiCheatSheet as ExploreStartPage,\n  LokiAnnotationsQueryCtrl as AnnotationsQueryCtrl,\n};\n","export const RATE_RANGES = ['1m', '5m', '10m', '30m', '1h'];\n\nexport const processHistogramLabels = (labels: string[]) => {\n  const result = [];\n  const regexp = new RegExp('_bucket($|:)');\n  for (let index = 0; index < labels.length; index++) {\n    const label = labels[index];\n    const isHistogramValue = regexp.test(label);\n    if (isHistogramValue) {\n      if (result.indexOf(label) === -1) {\n        result.push(label);\n      }\n    }\n  }\n\n  return { values: { __name__: result } };\n};\n\nexport function processLabels(labels: Array<{ [key: string]: string }>, withName = false) {\n  const values: { [key: string]: string[] } = {};\n  labels.forEach(l => {\n    const { __name__, ...rest } = l;\n    if (withName) {\n      values['__name__'] = values['__name__'] || [];\n      if (!values['__name__'].includes(__name__)) {\n        values['__name__'].push(__name__);\n      }\n    }\n\n    Object.keys(rest).forEach(key => {\n      if (!values[key]) {\n        values[key] = [];\n      }\n      if (!values[key].includes(rest[key])) {\n        values[key].push(rest[key]);\n      }\n    });\n  });\n  return { values, keys: Object.keys(values) };\n}\n\n// const cleanSelectorRegexp = /\\{(\\w+=\"[^\"\\n]*?\")(,\\w+=\"[^\"\\n]*?\")*\\}/;\nexport const selectorRegexp = /\\{[^}]*?\\}/;\nexport const labelRegexp = /\\b(\\w+)(!?=~?)(\"[^\"\\n]*?\")/g;\nexport function parseSelector(query: string, cursorOffset = 1): { labelKeys: any[]; selector: string } {\n  if (!query.match(selectorRegexp)) {\n    // Special matcher for metrics\n    if (query.match(/^[A-Za-z:][\\w:]*$/)) {\n      return {\n        selector: `{__name__=\"${query}\"}`,\n        labelKeys: ['__name__'],\n      };\n    }\n    throw new Error('Query must contain a selector: ' + query);\n  }\n\n  // Check if inside a selector\n  const prefix = query.slice(0, cursorOffset);\n  const prefixOpen = prefix.lastIndexOf('{');\n  const prefixClose = prefix.lastIndexOf('}');\n  if (prefixOpen === -1) {\n    throw new Error('Not inside selector, missing open brace: ' + prefix);\n  }\n  if (prefixClose > -1 && prefixClose > prefixOpen) {\n    throw new Error('Not inside selector, previous selector already closed: ' + prefix);\n  }\n  const suffix = query.slice(cursorOffset);\n  const suffixCloseIndex = suffix.indexOf('}');\n  const suffixClose = suffixCloseIndex + cursorOffset;\n  const suffixOpenIndex = suffix.indexOf('{');\n  const suffixOpen = suffixOpenIndex + cursorOffset;\n  if (suffixClose === -1) {\n    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);\n  }\n  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {\n    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);\n  }\n\n  // Extract clean labels to form clean selector, incomplete labels are dropped\n  const selector = query.slice(prefixOpen, suffixClose);\n  const labels: { [key: string]: { value: string; operator: string } } = {};\n  selector.replace(labelRegexp, (_, key, operator, value) => {\n    labels[key] = { value, operator };\n    return '';\n  });\n\n  // Add metric if there is one before the selector\n  const metricPrefix = query.slice(0, prefixOpen);\n  const metricMatch = metricPrefix.match(/[A-Za-z:][\\w:]*$/);\n  if (metricMatch) {\n    labels['__name__'] = { value: `\"${metricMatch[0]}\"`, operator: '=' };\n  }\n\n  // Build sorted selector\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');\n\n  const selectorString = ['{', cleanSelector, '}'].join('');\n\n  return { labelKeys, selector: selectorString };\n}\n\nexport function expandRecordingRules(query: string, mapping: { [name: string]: string }): string {\n  const ruleNames = Object.keys(mapping);\n  const rulesRegex = new RegExp(`(\\\\s|^)(${ruleNames.join('|')})(\\\\s|$|\\\\(|\\\\[|\\\\{)`, 'ig');\n  return query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`);\n}\n","import _ from 'lodash';\n\nconst keywords = 'by|without|on|ignoring|group_left|group_right|bool|or|and|unless';\n\n// Duplicate from mode-prometheus.js, which can't be used in tests due to global ace not being loaded.\nconst builtInWords = [\n  keywords,\n  'count|count_values|min|max|avg|sum|stddev|stdvar|bottomk|topk|quantile',\n  'true|false|null|__name__|job',\n  'abs|absent|ceil|changes|clamp_max|clamp_min|count_scalar|day_of_month|day_of_week|days_in_month|delta|deriv',\n  'drop_common_labels|exp|floor|histogram_quantile|holt_winters|hour|idelta|increase|irate|label_replace|ln|log2',\n  'log10|minute|month|predict_linear|rate|resets|round|scalar|sort|sort_desc|sqrt|time|vector|year|avg_over_time',\n  'min_over_time|max_over_time|sum_over_time|count_over_time|quantile_over_time|stddev_over_time|stdvar_over_time',\n]\n  .join('|')\n  .split('|');\n\nconst metricNameRegexp = /([A-Za-z:][\\w:]*)\\b(?![\\(\\]{=!\",])/g;\nconst selectorRegexp = /{([^{]*)}/g;\n\n// addLabelToQuery('foo', 'bar', 'baz') => 'foo{bar=\"baz\"}'\nexport function addLabelToQuery(query: string, key: string, value: string, operator?: string): string {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  // Add empty selectors to bare metric names\n  let previousWord: string;\n  query = query.replace(metricNameRegexp, (match, word, offset) => {\n    const insideSelector = isPositionInsideChars(query, offset, '{', '}');\n    // Handle \"sum by (key) (metric)\"\n    const previousWordIsKeyWord = previousWord && keywords.split('|').indexOf(previousWord) > -1;\n\n    // check for colon as as \"word boundary\" symbol\n    const isColonBounded = word.endsWith(':');\n\n    previousWord = word;\n    if (!insideSelector && !isColonBounded && !previousWordIsKeyWord && builtInWords.indexOf(word) === -1) {\n      return `${word}{}`;\n    }\n    return word;\n  });\n\n  // Adding label to existing selectors\n  let match = selectorRegexp.exec(query);\n  const parts = [];\n  let lastIndex = 0;\n  let suffix = '';\n\n  while (match) {\n    const prefix = query.slice(lastIndex, match.index);\n    const selector = match[1];\n    const selectorWithLabel = addLabelToSelector(selector, key, value, operator);\n    lastIndex = match.index + match[1].length + 2;\n    suffix = query.slice(match.index + match[0].length);\n    parts.push(prefix, selectorWithLabel);\n    match = selectorRegexp.exec(query);\n  }\n\n  parts.push(suffix);\n  return parts.join('');\n}\n\nconst labelRegexp = /(\\w+)\\s*(=|!=|=~|!~)\\s*(\"[^\"]*\")/g;\n\nexport function addLabelToSelector(selector: string, labelKey: string, labelValue: string, labelOperator?: string) {\n  const parsedLabels = [];\n\n  // Split selector into labels\n  if (selector) {\n    let match = labelRegexp.exec(selector);\n    while (match) {\n      parsedLabels.push({ key: match[1], operator: match[2], value: match[3] });\n      match = labelRegexp.exec(selector);\n    }\n  }\n\n  // Add new label\n  const operatorForLabelKey = labelOperator || '=';\n  parsedLabels.push({ key: labelKey, operator: operatorForLabelKey, value: `\"${labelValue}\"` });\n\n  // Sort labels by key and put them together\n  const formatted = _.chain(parsedLabels)\n    .uniqWith(_.isEqual)\n    .compact()\n    .sortBy('key')\n    .map(({ key, operator, value }) => `${key}${operator}${value}`)\n    .value()\n    .join(',');\n\n  return `{${formatted}}`;\n}\n\nfunction isPositionInsideChars(text: string, position: number, openChar: string, closeChar: string) {\n  const nextSelectorStart = text.slice(position).indexOf(openChar);\n  const nextSelectorEnd = text.slice(position).indexOf(closeChar);\n  return nextSelectorEnd > -1 && (nextSelectorStart === -1 || nextSelectorStart > nextSelectorEnd);\n}\n\nexport default addLabelToQuery;\n"],"sourceRoot":""}